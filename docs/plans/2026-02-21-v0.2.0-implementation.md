# v0.2.0 Improvements Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Fix navigation lag, make stop kill all processes + free ports, overhaul UI with modern dark theme and status colors, add auto-updater from GitHub Releases, and embed application icons cross-platform.

**Architecture:** Background worker thread for git status (mpsc channel), extended ProcessManager to track Claude terminal PIDs, centralized theme module, auto-updater using curl subprocess + GitHub API, and build.rs for Windows icon embedding.

**Tech Stack:** Rust, ratatui, crossterm, std::sync::mpsc, std::thread, winres (build-dep)

---

### Task 1: Create theme module with color constants

**Files:**
- Create: `src/theme.rs`
- Modify: `src/main.rs:1` (add `mod theme;`)

**Step 1: Create `src/theme.rs` with all color constants**

```rust
use ratatui::style::{Color, Modifier, Style};

// Base colors
pub const FG: Color = Color::Gray;
pub const FG_DIM: Color = Color::DarkGray;
pub const ACCENT: Color = Color::Cyan;

// Status colors
pub const STATUS_RUNNING: Color = Color::Green;
pub const STATUS_STOPPED: Color = Color::DarkGray;
pub const STATUS_PORT: Color = Color::Cyan;

// Git colors
pub const GIT_DIRTY: Color = Color::Yellow;
pub const GIT_AHEAD: Color = Color::Yellow;
pub const GIT_BEHIND: Color = Color::Red;
pub const GIT_CLEAN: Color = Color::Green;

// Border colors
pub const BORDER_ACTIVE: Color = Color::Cyan;
pub const BORDER_INACTIVE: Color = Color::DarkGray;

// Semantic colors
pub const DANGER: Color = Color::Red;
pub const WARNING: Color = Color::Yellow;

// Prebuilt styles
pub fn accent_title() -> Style {
    Style::default().fg(ACCENT)
}

pub fn label() -> Style {
    Style::default().fg(FG_DIM)
}

pub fn active_border() -> Style {
    Style::default().fg(BORDER_ACTIVE)
}

pub fn inactive_border() -> Style {
    Style::default().fg(BORDER_INACTIVE)
}

pub fn highlight() -> Style {
    Style::default()
        .bg(Color::Rgb(40, 44, 52))
        .add_modifier(Modifier::BOLD)
}

pub fn status_running() -> Style {
    Style::default().fg(STATUS_RUNNING)
}

pub fn status_stopped() -> Style {
    Style::default().fg(STATUS_STOPPED)
}
```

**Step 2: Add `mod theme;` to `src/main.rs`**

Add after line 4 (`mod gh;`):
```rust
mod theme;
```

**Step 3: Build to verify it compiles**

Run: `cargo build 2>&1`
Expected: Compiles with warnings about unused imports (expected at this stage)

**Step 4: Commit**

```bash
git add src/theme.rs src/main.rs
git commit -m "feat: add centralized theme module with color constants"
```

---

### Task 2: Apply theme to project list rendering

**Files:**
- Modify: `src/app.rs:1-8` (add theme import)
- Modify: `src/app.rs:909-936` (`render_project_list`)
- Modify: `src/app.rs:860-907` (`render_ports_bar`, `render_help_bar`)

**Step 1: Add theme import to app.rs**

Add `use crate::theme;` after line 17 (`use crate::store::{ProjectEntry, ProjectStore};`).

**Step 2: Rewrite `render_project_list` (lines 909-936)**

Replace the entire `render_project_list` method with:

```rust
fn render_project_list(&mut self, frame: &mut Frame, area: Rect) {
    let items: Vec<ListItem> = self
        .store
        .projects
        .iter()
        .map(|p| {
            let has_path = !p.path.is_empty() && Path::new(&p.path).exists();
            let is_running = self.process_manager.is_running(&p.name);

            // Find port for this project
            let port = self.process_manager.get_port(&p.name);

            let indicator = if is_running {
                Span::styled(" \u{25CF} ", Style::default().fg(theme::STATUS_RUNNING))
            } else if has_path {
                Span::styled(" \u{25CB} ", Style::default().fg(theme::STATUS_STOPPED))
            } else {
                Span::styled(" \u{25CB} ", Style::default().fg(theme::DANGER))
            };

            let name_style = if is_running {
                Style::default().fg(theme::FG)
            } else {
                Style::default().fg(theme::FG_DIM)
            };

            let mut spans = vec![indicator, Span::styled(&p.name, name_style)];

            // Show port badge if running
            if let Some(port) = port {
                spans.push(Span::styled(
                    format!(" :{}", port),
                    Style::default().fg(theme::STATUS_PORT),
                ));
            }

            // Show dirty indicator if we have cached git status
            // (will be connected in Task 4)

            ListItem::new(Line::from(spans))
        })
        .collect();

    let list = List::new(items)
        .block(
            Block::default()
                .borders(Borders::ALL)
                .title(" Projects ")
                .title_style(theme::accent_title())
                .border_style(theme::active_border()),
        )
        .highlight_style(theme::highlight())
        .highlight_symbol("\u{25B6} ");

    frame.render_stateful_widget(list, area, &mut self.list_state);
}
```

**Step 3: Rewrite `render_ports_bar` (lines 860-888)**

Replace with:

```rust
fn render_ports_bar(&self, frame: &mut Frame, area: Rect) {
    let running = self.process_manager.running_projects();
    let running_count = running.len();

    let mut spans: Vec<Span> = vec![];

    // Running count
    if running_count > 0 {
        spans.push(Span::styled(
            format!(" {} running", running_count),
            Style::default().fg(theme::STATUS_RUNNING),
        ));
        spans.push(Span::styled(" \u{2502} ", theme::label()));
    }

    // Active ports
    let port_spans: Vec<String> = self
        .port_info
        .iter()
        .map(|p| format!("{}", p.port))
        .collect();

    if !port_spans.is_empty() {
        spans.push(Span::styled("ports: ", theme::label()));
        spans.push(Span::styled(
            port_spans.join(", "),
            Style::default().fg(theme::STATUS_PORT),
        ));
    } else {
        spans.push(Span::styled("no active ports", theme::label()));
    }

    // Version
    spans.push(Span::styled(
        format!(" \u{2502} v{}", env!("CARGO_PKG_VERSION")),
        theme::label(),
    ));

    let content = Line::from(spans);
    let para = Paragraph::new(content);
    frame.render_widget(para, area);
}
```

**Step 4: Rewrite `render_help_bar` (lines 890-907)**

Replace with:

```rust
fn render_help_bar(&self, frame: &mut Frame, area: Rect) {
    let gh_label = if self.gh_available {
        "[a]dd"
    } else {
        "[a]dd(no gh)"
    };

    let help_spans = vec![
        Span::styled(format!(" {}  ", gh_label), theme::label()),
        Span::styled("[i]mport  ", theme::label()),
        Span::styled("[s]can  ", theme::label()),
        Span::styled("[g]it  ", theme::label()),
        Span::styled("[e]dit  ", theme::label()),
        Span::styled("[r]un  ", Style::default().fg(theme::STATUS_RUNNING)),
        Span::styled("[x]stop  ", Style::default().fg(theme::DANGER)),
        Span::styled("[d]el  ", theme::label()),
        Span::styled("[c]fg  ", theme::label()),
        Span::styled("[F5]  ", theme::label()),
        Span::styled("[q]uit", theme::label()),
    ];

    let help = Paragraph::new(Line::from(help_spans));
    frame.render_widget(help, area);
}
```

**Step 5: Rewrite `render_details` (lines 938-1044) with themed sections**

Replace with:

```rust
fn render_details(&self, frame: &mut Frame, area: Rect) {
    let content = if let Some(project) = self.selected_project() {
        let repo_display = project.repo_url.as_deref().unwrap_or("");

        let mut lines = vec![
            Line::from(vec![
                Span::styled("  Name      ", theme::label()),
                Span::raw(&project.name),
            ]),
            Line::from(vec![
                Span::styled("  Repo      ", theme::label()),
                Span::raw(repo_display),
            ]),
        ];

        let has_path = !project.path.is_empty() && Path::new(&project.path).exists();

        if has_path {
            lines.push(Line::from(vec![
                Span::styled("  Path      ", theme::label()),
                Span::raw(&project.path),
            ]));

            // Detection info
            if let Some(ref det) = self.selected_detection {
                lines.push(Line::from(vec![
                    Span::styled("  Type      ", theme::label()),
                    Span::raw(if let Some(pm) = det.package_manager {
                        format!("{:?} ({})", det.project_type, pm.as_str())
                    } else {
                        format!("{:?}", det.project_type)
                    }),
                ]));
            }

            lines.push(Line::from(""));

            // Git section
            lines.push(Line::from(vec![
                Span::styled("  \u{2500}\u{2500} Git \u{2500}\u{2500}", Style::default().fg(theme::ACCENT)),
            ]));

            if let Some(ref git) = self.selected_git_status {
                lines.push(Line::from(vec![
                    Span::styled("  Branch    ", theme::label()),
                    Span::raw(&git.branch),
                ]));

                let status_text = if git.staged == 0 && git.modified == 0 && git.untracked == 0 {
                    Span::styled("\u{2713} clean", Style::default().fg(theme::GIT_CLEAN))
                } else {
                    Span::styled(
                        format!("{} staged, {} modified, {} untracked", git.staged, git.modified, git.untracked),
                        Style::default().fg(theme::GIT_DIRTY),
                    )
                };
                lines.push(Line::from(vec![
                    Span::styled("  Status    ", theme::label()),
                    status_text,
                ]));

                lines.push(Line::from(vec![
                    Span::styled("  Ahead     ", theme::label()),
                    Span::styled(
                        git.ahead.to_string(),
                        Style::default().fg(if git.ahead > 0 { theme::GIT_AHEAD } else { Color::White }),
                    ),
                    Span::raw("    "),
                    Span::styled("Behind  ", theme::label()),
                    Span::styled(
                        git.behind.to_string(),
                        Style::default().fg(if git.behind > 0 { theme::GIT_BEHIND } else { Color::White }),
                    ),
                ]));
            } else {
                lines.push(Line::from(vec![
                    Span::styled("  Loading...", theme::label()),
                ]));
            }

            lines.push(Line::from(""));

            // Runtime section
            lines.push(Line::from(vec![
                Span::styled("  \u{2500}\u{2500} Runtime \u{2500}\u{2500}", Style::default().fg(theme::ACCENT)),
            ]));

            let is_running = self.process_manager.is_running(&project.name);
            let port = self.process_manager.get_port(&project.name);

            lines.push(Line::from(vec![
                Span::styled("  Status    ", theme::label()),
                if is_running {
                    Span::styled("\u{25CF} Running", Style::default().fg(theme::STATUS_RUNNING))
                } else {
                    Span::styled("\u{25CB} Stopped", Style::default().fg(theme::STATUS_STOPPED))
                },
            ]));

            if let Some(port) = port {
                lines.push(Line::from(vec![
                    Span::styled("  Port      ", theme::label()),
                    Span::styled(port.to_string(), Style::default().fg(theme::STATUS_PORT)),
                ]));
            }

            let cmd = project.run_command.as_ref().or_else(|| {
                self.selected_detection.as_ref().and_then(|d| d.run_command.as_ref())
            });
            if let Some(cmd) = cmd {
                lines.push(Line::from(vec![
                    Span::styled("  Command   ", theme::label()),
                    Span::raw(cmd),
                ]));
            }

            if let Some(ref cmd) = project.run_command {
                lines.push(Line::from(vec![
                    Span::styled("  Override  ", Style::default().fg(theme::WARNING)),
                    Span::raw(cmd),
                ]));
            }
        } else {
            lines.push(Line::from(""));
            lines.push(Line::from(Span::styled(
                "  Path not set",
                Style::default().fg(theme::DANGER),
            )));
            if project.repo_url.is_some() {
                lines.push(Line::from(Span::styled(
                    "  Press 'g' to clone from repo",
                    theme::label(),
                )));
            }
        }

        lines
    } else {
        vec![Line::from("  No project selected")]
    };

    let para = Paragraph::new(content).block(
        Block::default()
            .borders(Borders::ALL)
            .title(" Details ")
            .title_style(theme::accent_title())
            .border_style(theme::active_border()),
    );
    frame.render_widget(para, area);
}
```

**Step 6: Update `render_logs` (lines 832-858) and `render_quit_dialog` (lines 808-830) with theme**

For `render_logs`, update the block:
```rust
fn render_logs(&mut self, frame: &mut Frame, area: Rect) {
    // ... existing logic for title and lines stays the same ...

    let para = Paragraph::new(visible_lines).block(
        Block::default()
            .borders(Borders::ALL)
            .title(title)
            .title_style(theme::accent_title())
            .border_style(theme::inactive_border()),
    );
    frame.render_widget(para, area);
}
```

For `render_quit_dialog`, update to use theme colors:
```rust
fn render_quit_dialog(&self, frame: &mut Frame, area: Rect) {
    use ratatui::widgets::Clear;

    let width = 40.min(area.width.saturating_sub(4));
    let height = 3;
    let x = (area.width.saturating_sub(width)) / 2;
    let y = (area.height.saturating_sub(height)) / 2;
    let dialog_area = Rect::new(x, y, width, height);

    frame.render_widget(Clear, dialog_area);

    let text = Paragraph::new("Quit? (y/n)")
        .style(Style::default().fg(Color::White))
        .block(
            Block::default()
                .borders(Borders::ALL)
                .title(" Confirm ")
                .border_style(Style::default().fg(theme::WARNING)),
        )
        .alignment(ratatui::layout::Alignment::Center);

    frame.render_widget(text, dialog_area);
}
```

**Step 7: Add `get_port` method to ProcessManager**

The `render_project_list` and `render_details` methods now call `self.process_manager.get_port(&name)`. Add this method to `src/process.rs`:

Add a new field `ports: HashMap<String, u16>` to `ProcessManager` and methods to manage it:

In `ProcessManager` struct (line 9-12), add `ports` field:
```rust
pub struct ProcessManager {
    processes: HashMap<String, Child>,
    output_buffers: Arc<Mutex<HashMap<String, Vec<String>>>>,
    ports: HashMap<String, u16>,
}
```

In `new()` (line 15-19), add initialization:
```rust
pub fn new() -> Self {
    Self {
        processes: HashMap::new(),
        output_buffers: Arc::new(Mutex::new(HashMap::new())),
        ports: HashMap::new(),
    }
}
```

In `start_with_port()` after line 126 (`self.processes.insert(key, child);`), add:
```rust
if let Some(p) = port {
    self.ports.insert(project_name.to_string(), p);
}
```

In `stop()` after buffer cleanup (line 153), add:
```rust
self.ports.remove(project_name);
```

Add new method after `running_projects()`:
```rust
pub fn get_port(&self, project_name: &str) -> Option<u16> {
    self.ports.get(project_name).copied()
}
```

Update `Default` implementation:
```rust
impl Default for ProcessManager {
    fn default() -> Self {
        Self::new()
    }
}
```

**Step 8: Fix `is_running` borrow issue**

The `render_project_list` method calls `self.process_manager.is_running()` which takes `&mut self`. This conflicts with iterating `self.store.projects`. Change `is_running` to take `&self` by collecting dead processes separately:

Replace `is_running` in `process.rs` (lines 158-172):

```rust
pub fn is_running(&self, project_name: &str) -> bool {
    self.processes.contains_key(project_name)
}

pub fn reap_dead(&mut self) {
    let dead: Vec<String> = self
        .processes
        .iter_mut()
        .filter_map(|(name, child)| match child.try_wait() {
            Ok(Some(_)) => Some(name.clone()),
            _ => None,
        })
        .collect();
    for name in dead {
        self.processes.remove(&name);
        self.ports.remove(&name);
    }
}
```

Then call `self.process_manager.reap_dead()` at the start of `App::render()` (before `maybe_refresh_ports()`).

**Step 9: Build and verify**

Run: `cargo build 2>&1`
Expected: Compiles successfully

**Step 10: Commit**

```bash
git add src/app.rs src/process.rs
git commit -m "feat: apply modern dark theme with status colors to all UI panels"
```

---

### Task 3: Background git status worker (fix navigation lag)

**Files:**
- Create: `src/git_worker.rs`
- Modify: `src/main.rs` (add `mod git_worker;`)
- Modify: `src/app.rs` (use git worker instead of blocking calls)

**Step 1: Create `src/git_worker.rs`**

```rust
use std::collections::HashMap;
use std::path::PathBuf;
use std::sync::mpsc::{self, Receiver, Sender};
use std::thread;
use std::time::Instant;

use crate::detect::{self, DetectedProject};
use crate::git_status::{self, GitStatus};

pub struct GitStatusResult {
    pub path: String,
    pub git_status: Option<GitStatus>,
    pub detection: Option<DetectedProject>,
}

pub struct GitWorker {
    request_tx: Sender<String>,
    result_rx: Receiver<GitStatusResult>,
    cache: HashMap<String, CachedEntry>,
}

struct CachedEntry {
    git_status: Option<GitStatus>,
    detection: Option<DetectedProject>,
    fetched_at: Instant,
}

impl GitWorker {
    pub fn new() -> Self {
        let (request_tx, request_rx) = mpsc::channel::<String>();
        let (result_tx, result_rx) = mpsc::channel::<GitStatusResult>();

        thread::spawn(move || {
            while let Ok(path_str) = request_rx.recv() {
                let path = PathBuf::from(&path_str);
                let git_status = if path.join(".git").exists() {
                    git_status::get_status(&path).ok()
                } else {
                    None
                };
                let detection = detect::detect(&path).ok();

                let _ = result_tx.send(GitStatusResult {
                    path: path_str,
                    git_status,
                    detection,
                });
            }
        });

        Self {
            request_tx,
            result_rx,
            cache: HashMap::new(),
        }
    }

    /// Request a background status fetch for a path
    pub fn request(&self, path: &str) {
        let _ = self.request_tx.send(path.to_string());
    }

    /// Poll for completed results, updating cache. Call this in the event loop.
    pub fn poll(&mut self) -> bool {
        let mut updated = false;
        while let Ok(result) = self.result_rx.try_recv() {
            self.cache.insert(
                result.path,
                CachedEntry {
                    git_status: result.git_status,
                    detection: result.detection,
                    fetched_at: Instant::now(),
                },
            );
            updated = true;
        }
        updated
    }

    /// Get cached git status for a path
    pub fn get_git_status(&self, path: &str) -> Option<&GitStatus> {
        self.cache.get(path).and_then(|e| e.git_status.as_ref())
    }

    /// Get cached detection for a path
    pub fn get_detection(&self, path: &str) -> Option<&DetectedProject> {
        self.cache.get(path).and_then(|e| e.detection.as_ref())
    }

    /// Check if cache entry is stale (older than 30 seconds)
    pub fn is_stale(&self, path: &str) -> bool {
        match self.cache.get(path) {
            Some(entry) => entry.fetched_at.elapsed().as_secs() > 30,
            None => true,
        }
    }

    /// Invalidate all cache entries (for F5 refresh)
    pub fn invalidate_all(&mut self) {
        self.cache.clear();
    }
}
```

**Step 2: Add `mod git_worker;` to `src/main.rs`**

Add after `mod gh;`:
```rust
mod git_worker;
```

**Step 3: Integrate GitWorker into App**

In `src/app.rs`, make these changes:

Add import at top:
```rust
use crate::git_worker::GitWorker;
```

Add field to `App` struct (after `should_quit: bool,`):
```rust
git_worker: GitWorker,
```

In `App::new()`, initialize the git_worker:
```rust
git_worker: GitWorker::new(),
```

Remove the call to `app.update_selected_details();` from `App::new()` and replace with a background request:
```rust
if let Some(project) = app.store.projects.first() {
    if !project.path.is_empty() {
        app.git_worker.request(&project.path);
    }
}
```

**Step 4: Make `update_selected_details` non-blocking**

Replace `update_selected_details` (lines 720-735) with:

```rust
fn update_selected_details(&mut self) {
    if let Some(idx) = self.list_state.selected() {
        if let Some(project) = self.store.projects.get(idx) {
            if !project.path.is_empty() && Path::new(&project.path).exists() {
                // Use cached data immediately
                self.selected_detection = self.git_worker.get_detection(&project.path).cloned();
                self.selected_git_status = self.git_worker.get_git_status(&project.path).cloned();

                // Request fresh data in background if stale
                if self.git_worker.is_stale(&project.path) {
                    self.git_worker.request(&project.path);
                }
                return;
            }
        }
    }
    self.selected_detection = None;
    self.selected_git_status = None;
}
```

**Step 5: Add poll call to render loop**

In `App::render()`, at the very beginning (before `self.maybe_refresh_ports();`), add:

```rust
// Poll for background git status results
if self.git_worker.poll() {
    // Update selected details from fresh cache
    if let Some(idx) = self.list_state.selected() {
        if let Some(project) = self.store.projects.get(idx) {
            if !project.path.is_empty() {
                self.selected_detection = self.git_worker.get_detection(&project.path).cloned();
                self.selected_git_status = self.git_worker.get_git_status(&project.path).cloned();
            }
        }
    }
}
```

**Step 6: Update `full_refresh` to invalidate cache**

In `full_refresh()`, add after `self.store = reloaded;`:
```rust
self.git_worker.invalidate_all();
```

And ensure it sends a new request for the selected project at the end:
```rust
fn full_refresh(&mut self) {
    if let Ok(reloaded) = ProjectStore::load() {
        self.store = reloaded;
    }
    self.git_worker.invalidate_all();
    self.port_info = ports::scan_ports();
    self.last_port_scan = std::time::Instant::now();
    self.update_selected_details();
}
```

**Step 7: Build and verify**

Run: `cargo build 2>&1`
Expected: Compiles successfully

**Step 8: Commit**

```bash
git add src/git_worker.rs src/app.rs src/main.rs
git commit -m "feat: background git status worker to fix navigation lag"
```

---

### Task 4: Stop kills everything (port + Claude terminal)

**Files:**
- Modify: `src/process.rs` (add Claude PID tracking)
- Modify: `src/app.rs` (capture terminal PID, enhanced stop)

**Step 1: Add Claude PID tracking to ProcessManager**

Add a new field to `ProcessManager`:
```rust
pub struct ProcessManager {
    processes: HashMap<String, Child>,
    output_buffers: Arc<Mutex<HashMap<String, Vec<String>>>>,
    ports: HashMap<String, u16>,
    claude_pids: HashMap<String, u32>,
}
```

Initialize in `new()`:
```rust
claude_pids: HashMap::new(),
```

Add methods:
```rust
pub fn set_claude_pid(&mut self, project_name: &str, pid: u32) {
    self.claude_pids.insert(project_name.to_string(), pid);
}

fn kill_claude_terminal(&mut self, project_name: &str) {
    if let Some(pid) = self.claude_pids.remove(project_name) {
        #[cfg(windows)]
        {
            let _ = Command::new("taskkill")
                .args(["/PID", &pid.to_string(), "/T", "/F"])
                .stdout(Stdio::null())
                .stderr(Stdio::null())
                .status();
        }

        #[cfg(unix)]
        {
            unsafe {
                // Kill process group
                libc::kill(-(pid as i32), libc::SIGTERM);
            }
            // Give it a moment, then force kill
            std::thread::sleep(std::time::Duration::from_millis(200));
            unsafe {
                libc::kill(-(pid as i32), libc::SIGKILL);
            }
        }
    }
}
```

**Step 2: Update `stop()` to kill Claude terminal and verify port freed**

Replace `stop()` in `process.rs`:

```rust
pub fn stop(&mut self, project_name: &str) -> Result<()> {
    // Kill dev server
    if let Some(mut child) = self.processes.remove(project_name) {
        #[cfg(unix)]
        {
            unsafe {
                libc::kill(child.id() as i32, libc::SIGTERM);
            }
        }
        #[cfg(windows)]
        {
            let _ = child.kill();
        }

        std::thread::sleep(std::time::Duration::from_millis(500));
        let _ = child.kill();
        let _ = child.wait();
    }

    // Kill Claude terminal
    self.kill_claude_terminal(project_name);

    // Verify port is freed
    if let Some(port) = self.ports.remove(project_name) {
        for _ in 0..10 {
            if !Self::is_port_open(port) {
                break;
            }
            std::thread::sleep(std::time::Duration::from_millis(200));
        }
    }

    // Clean up buffer
    if let Ok(mut buffers) = self.output_buffers.lock() {
        buffers.remove(project_name);
    }

    Ok(())
}

fn is_port_open(port: u16) -> bool {
    use std::net::TcpStream;
    TcpStream::connect_timeout(
        &format!("127.0.0.1:{}", port).parse().unwrap(),
        std::time::Duration::from_millis(50),
    )
    .is_ok()
}
```

**Step 3: Capture Claude terminal PID in `spawn_terminal_with_claude`**

In `src/app.rs`, change `spawn_terminal_with_claude` signature and capture PIDs.

Change the method to return `Option<u32>` and store it:

```rust
fn spawn_terminal_with_claude(&mut self, path: &Path, project_name: &str) {
    use std::process::Command;

    let path_str = path.to_string_lossy().to_string();

    #[cfg(target_os = "windows")]
    {
        let child = if Command::new("where")
            .arg("wt")
            .output()
            .map(|o| o.status.success())
            .unwrap_or(false)
        {
            Command::new("wt")
                .args(["-d", &path_str, "cmd", "/k", "claude"])
                .spawn()
                .ok()
        } else {
            Command::new("cmd")
                .args(["/c", "start", "cmd", "/k", &format!("cd /d \"{}\" && claude", path_str)])
                .spawn()
                .ok()
        };

        if let Some(child) = child {
            self.process_manager.set_claude_pid(project_name, child.id());
        }
    }

    #[cfg(target_os = "linux")]
    {
        // Try common Linux terminal emulators in order of preference
        let child = if Command::new("which").arg("ghostty").output().map(|o| o.status.success()).unwrap_or(false) {
            let shell_cmd = format!("cd '{}' && claude; exec $SHELL", path_str);
            Command::new("ghostty")
                .args(["-e", "bash", "-c", &shell_cmd])
                .stdout(std::process::Stdio::null())
                .stderr(std::process::Stdio::null())
                .spawn()
                .ok()
        } else if Command::new("which").arg("alacritty").output().map(|o| o.status.success()).unwrap_or(false) {
            Command::new("alacritty")
                .args(["--working-directory", &path_str, "-e", "claude"])
                .stdout(std::process::Stdio::null())
                .stderr(std::process::Stdio::null())
                .spawn()
                .ok()
        } else if Command::new("which").arg("kitty").output().map(|o| o.status.success()).unwrap_or(false) {
            Command::new("kitty")
                .args(["--directory", &path_str, "claude"])
                .stdout(std::process::Stdio::null())
                .stderr(std::process::Stdio::null())
                .spawn()
                .ok()
        } else if Command::new("which").arg("gnome-terminal").output().map(|o| o.status.success()).unwrap_or(false) {
            Command::new("gnome-terminal")
                .args(["--working-directory", &path_str, "--", "claude"])
                .stdout(std::process::Stdio::null())
                .stderr(std::process::Stdio::null())
                .spawn()
                .ok()
        } else if Command::new("which").arg("konsole").output().map(|o| o.status.success()).unwrap_or(false) {
            Command::new("konsole")
                .args(["--workdir", &path_str, "-e", "claude"])
                .stdout(std::process::Stdio::null())
                .stderr(std::process::Stdio::null())
                .spawn()
                .ok()
        } else if Command::new("which").arg("xfce4-terminal").output().map(|o| o.status.success()).unwrap_or(false) {
            Command::new("xfce4-terminal")
                .args(["--working-directory", &path_str, "-e", "claude"])
                .stdout(std::process::Stdio::null())
                .stderr(std::process::Stdio::null())
                .spawn()
                .ok()
        } else if Command::new("which").arg("xterm").output().map(|o| o.status.success()).unwrap_or(false) {
            let xterm_cmd = format!("cd '{}' && claude", path_str);
            Command::new("xterm")
                .args(["-e", &xterm_cmd])
                .stdout(std::process::Stdio::null())
                .stderr(std::process::Stdio::null())
                .spawn()
                .ok()
        } else {
            None
        };

        if let Some(child) = child {
            self.process_manager.set_claude_pid(project_name, child.id());
        }
    }

    #[cfg(target_os = "macos")]
    {
        let script = format!(
            r#"tell application "Terminal"
                activate
                do script "cd '{}' && claude"
            end tell"#,
            path_str
        );
        let _ = Command::new("osascript")
            .args(["-e", &script])
            .spawn();
        // Note: macOS osascript doesn't give us the Terminal.app PID easily
    }
}
```

**Step 4: Update `run_selected` to pass project_name**

In `run_selected()`, change the `spawn_terminal_with_claude` call (line 505):

```rust
self.spawn_terminal_with_claude(path, &project_name);
```

Since `spawn_terminal_with_claude` now takes `&mut self`, and `run_selected` already has `&mut self`, update the method signature:
```rust
fn spawn_terminal_with_claude(&mut self, path: &Path, project_name: &str) {
```

**Step 5: Build and verify**

Run: `cargo build 2>&1`
Expected: Compiles successfully

**Step 6: Commit**

```bash
git add src/process.rs src/app.rs
git commit -m "feat: stop kills Claude terminal, dev server, and frees port"
```

---

### Task 5: Auto-updater

**Files:**
- Create: `src/updater.rs`
- Modify: `src/main.rs` (add mod)
- Modify: `src/app.rs` (integrate update notification + keybind)

**Step 1: Create `src/updater.rs`**

```rust
use std::sync::mpsc::{self, Receiver};
use std::thread;

#[derive(Clone, Debug)]
pub struct UpdateInfo {
    pub version: String,
    pub download_url: String,
}

pub struct UpdateChecker {
    result_rx: Receiver<Option<UpdateInfo>>,
}

impl UpdateChecker {
    /// Spawn a background thread to check for updates
    pub fn check_in_background(owner: &str, repo: &str) -> Self {
        let (tx, rx) = mpsc::channel();
        let url = format!(
            "https://api.github.com/repos/{}/{}/releases/latest",
            owner, repo
        );
        let current_version = env!("CARGO_PKG_VERSION").to_string();

        thread::spawn(move || {
            let result = check_for_update(&url, &current_version);
            let _ = tx.send(result);
        });

        Self { result_rx: rx }
    }

    /// Non-blocking poll for result
    pub fn poll(&self) -> Option<Option<UpdateInfo>> {
        self.result_rx.try_recv().ok()
    }
}

fn check_for_update(api_url: &str, current_version: &str) -> Option<UpdateInfo> {
    use std::process::Command;

    // Use curl to fetch the latest release info
    #[cfg(windows)]
    let output = Command::new("curl.exe")
        .args(["-s", "-L", "--max-time", "10", api_url])
        .output()
        .ok()?;

    #[cfg(not(windows))]
    let output = Command::new("curl")
        .args(["-s", "-L", "--max-time", "10", api_url])
        .output()
        .ok()?;

    if !output.status.success() {
        return None;
    }

    let body = String::from_utf8_lossy(&output.stdout);

    // Parse tag_name from JSON (simple extraction, no serde needed)
    let tag = extract_json_string(&body, "tag_name")?;
    let version = tag.trim_start_matches('v');

    // Compare versions
    if version_is_newer(version, current_version) {
        // Find the appropriate download URL for this platform
        let asset_name = platform_asset_name();
        let download_url = find_asset_url(&body, &asset_name)?;

        Some(UpdateInfo {
            version: version.to_string(),
            download_url,
        })
    } else {
        None
    }
}

fn extract_json_string(json: &str, key: &str) -> Option<String> {
    let pattern = format!("\"{}\"", key);
    let start = json.find(&pattern)? + pattern.len();
    let rest = &json[start..];
    // Skip whitespace and colon
    let rest = rest.trim_start();
    let rest = rest.strip_prefix(':')?;
    let rest = rest.trim_start();
    let rest = rest.strip_prefix('"')?;
    let end = rest.find('"')?;
    Some(rest[..end].to_string())
}

fn find_asset_url(json: &str, asset_name: &str) -> Option<String> {
    // Find "browser_download_url" that contains the asset name
    let mut search_from = 0;
    while let Some(pos) = json[search_from..].find("browser_download_url") {
        let abs_pos = search_from + pos;
        let rest = &json[abs_pos..];
        if let Some(url) = extract_json_string(rest, "browser_download_url") {
            if url.contains(asset_name) {
                return Some(url);
            }
        }
        search_from = abs_pos + 1;
    }
    None
}

fn platform_asset_name() -> String {
    #[cfg(target_os = "windows")]
    return "x86_64-pc-windows-msvc".to_string();

    #[cfg(target_os = "linux")]
    return "x86_64-unknown-linux-gnu".to_string();

    #[cfg(target_os = "macos")]
    return "aarch64-apple-darwin".to_string();

    #[cfg(not(any(target_os = "windows", target_os = "linux", target_os = "macos")))]
    return "unknown".to_string();
}

fn version_is_newer(remote: &str, local: &str) -> bool {
    let parse = |v: &str| -> Vec<u32> {
        v.split('.')
            .filter_map(|s| s.parse().ok())
            .collect()
    };
    let r = parse(remote);
    let l = parse(local);
    r > l
}

/// Download and apply update. Returns Ok(()) if successful.
pub fn apply_update(info: &UpdateInfo) -> anyhow::Result<()> {
    use std::process::Command;

    let exe_path = std::env::current_exe()?;
    let exe_dir = exe_path.parent().ok_or_else(|| anyhow::anyhow!("No parent dir"))?;

    // Download to temp file
    #[cfg(windows)]
    let archive_name = "claude-manager-update.zip";
    #[cfg(not(windows))]
    let archive_name = "claude-manager-update.tar.gz";

    let archive_path = exe_dir.join(archive_name);

    #[cfg(windows)]
    {
        let status = Command::new("curl.exe")
            .args([
                "-s", "-L", "--max-time", "120",
                "-o", &archive_path.to_string_lossy(),
                &info.download_url,
            ])
            .status()?;
        if !status.success() {
            anyhow::bail!("Download failed");
        }

        // Extract using tar (available on Windows 10+)
        let temp_dir = exe_dir.join("_update_temp");
        let _ = std::fs::create_dir_all(&temp_dir);
        let status = Command::new("tar")
            .args([
                "-xf",
                &archive_path.to_string_lossy(),
                "-C",
                &temp_dir.to_string_lossy(),
            ])
            .status()?;
        if !status.success() {
            anyhow::bail!("Extract failed");
        }

        // Rename current exe to .old, move new into place
        let old_path = exe_path.with_extension("exe.old");
        let _ = std::fs::remove_file(&old_path);
        std::fs::rename(&exe_path, &old_path)?;
        std::fs::rename(temp_dir.join("claude-manager.exe"), &exe_path)?;

        // Cleanup
        let _ = std::fs::remove_dir_all(&temp_dir);
        let _ = std::fs::remove_file(&archive_path);
    }

    #[cfg(not(windows))]
    {
        let status = Command::new("curl")
            .args([
                "-s", "-L", "--max-time", "120",
                "-o", &archive_path.to_string_lossy(),
                &info.download_url,
            ])
            .status()?;
        if !status.success() {
            anyhow::bail!("Download failed");
        }

        // Extract
        let temp_dir = exe_dir.join("_update_temp");
        let _ = std::fs::create_dir_all(&temp_dir);
        let status = Command::new("tar")
            .args([
                "-xzf",
                &archive_path.to_string_lossy(),
                "-C",
                &temp_dir.to_string_lossy(),
            ])
            .status()?;
        if !status.success() {
            anyhow::bail!("Extract failed");
        }

        // Replace binary
        std::fs::rename(temp_dir.join("claude-manager"), &exe_path)?;

        // Make executable
        #[cfg(unix)]
        {
            use std::os::unix::fs::PermissionsExt;
            let mut perms = std::fs::metadata(&exe_path)?.permissions();
            perms.set_mode(0o755);
            std::fs::set_permissions(&exe_path, perms)?;
        }

        // Cleanup
        let _ = std::fs::remove_dir_all(&temp_dir);
        let _ = std::fs::remove_file(&archive_path);
    }

    Ok(())
}

/// Clean up old exe from previous update (Windows only)
pub fn cleanup_old_exe() {
    #[cfg(windows)]
    {
        if let Ok(exe_path) = std::env::current_exe() {
            let old_path = exe_path.with_extension("exe.old");
            let _ = std::fs::remove_file(old_path);
        }
    }
}
```

**Step 2: Add `mod updater;` to `src/main.rs`**

After `mod theme;`:
```rust
mod updater;
```

**Step 3: Integrate into App**

Add to `src/app.rs` imports:
```rust
use crate::updater::{self, UpdateChecker, UpdateInfo};
```

Add fields to `App` struct:
```rust
update_checker: Option<UpdateChecker>,
update_available: Option<UpdateInfo>,
update_status: Option<String>,
```

Initialize in `App::new()`:
```rust
update_checker: Some(UpdateChecker::check_in_background("stephenfjohnson", "claude-manager")),
update_available: None,
update_status: None,
```

Add cleanup call at the start of `main()`:
```rust
updater::cleanup_old_exe();
```

**Step 4: Poll for update result in render**

In `App::render()`, after the git_worker poll, add:

```rust
// Poll for update check result
if let Some(ref checker) = self.update_checker {
    if let Some(result) = checker.poll() {
        self.update_available = result;
        self.update_checker = None;
    }
}
```

**Step 5: Render update notification bar**

If `update_available` is `Some`, render a notification at the top of the screen. Modify the layout in `render()` to include an optional top bar:

Add at the start of `render()` after the polls:

```rust
let has_update = self.update_available.is_some() || self.update_status.is_some();
```

Then add a conditional top bar in the layout. The simplest approach: render a notification bar within the existing ports bar area, or add an `InputMode::Updating` state.

Simpler approach â€” add to `render_ports_bar`:

At the end of `render_ports_bar`, if update is available, append to spans:

```rust
// In render_ports_bar, before creating the Line:
if let Some(ref update) = self.update_available {
    spans.push(Span::styled(" \u{2502} ", theme::label()));
    spans.push(Span::styled(
        format!("Update v{} available [u]", update.version),
        Style::default().fg(theme::WARNING),
    ));
}
if let Some(ref status) = self.update_status {
    spans.push(Span::styled(" \u{2502} ", theme::label()));
    spans.push(Span::styled(status, Style::default().fg(theme::ACCENT)));
}
```

**Step 6: Handle `u` keybind for update**

In `handle_normal_key`, add:

```rust
KeyCode::Char('u') => {
    if let Some(ref info) = self.update_available.clone() {
        self.update_status = Some("Downloading update...".to_string());
        match updater::apply_update(info) {
            Ok(()) => {
                self.update_status = Some(format!("Updated to v{}! Restart to apply.", info.version));
                self.update_available = None;
            }
            Err(e) => {
                self.update_status = Some(format!("Update failed: {}", e));
            }
        }
    }
}
```

**Step 7: Build and verify**

Run: `cargo build 2>&1`
Expected: Compiles successfully

**Step 8: Commit**

```bash
git add src/updater.rs src/app.rs src/main.rs
git commit -m "feat: auto-updater checks GitHub Releases on launch"
```

---

### Task 6: Application icon (Windows, macOS, Linux)

**Files:**
- Create: `assets/icon.ico` (generate programmatically via script)
- Create: `assets/icon.png`
- Create: `build.rs`
- Modify: `Cargo.toml` (add winres build-dep, bump version)
- Modify: `.github/workflows/release.yml` (include icon assets)

**Step 1: Create the assets directory and generate icon**

Create `assets/` directory and a simple icon. We'll use a Python script (or manual creation) to generate a basic icon. For CI, the icon files should be committed as binary assets.

For now, create a minimal valid ICO file programmatically using a Rust build script, or download/create a simple icon.

The simplest approach: create a minimal 16x16 and 32x32 ICO from raw bytes. However, this is complex. Instead, we'll create a simple BMP-based ICO.

Alternative approach: use the `embed-resource` or `winres` crate with a pre-made `.ico` file. We need to create the icon file first.

Create `assets/icon.rc` (Windows resource file):
```
1 ICON "icon.ico"
```

For the actual icon generation, we'll use a simple approach:
- Create a minimal valid `.ico` file with a single 32x32 image
- The icon will be a cyan `>_` symbol on dark background

Since generating ICO files in-repo is non-trivial without tooling, we'll use the `winres` crate which can work with `.ico` files.

**Step 2: Create `build.rs`**

```rust
fn main() {
    #[cfg(windows)]
    {
        let mut res = winres::WindowsResource::new();
        res.set_icon("assets/icon.ico");
        if let Err(e) = res.compile() {
            eprintln!("Warning: Failed to set icon: {}", e);
        }
    }
}
```

**Step 3: Update `Cargo.toml`**

Change version to `0.2.0` and add winres build dependency:

```toml
[package]
name = "claude-manager"
version = "0.2.0"
edition = "2021"

[dependencies]
anyhow = "1"
crossterm = { version = "0.28", features = ["bracketed-paste"] }
dirs = "5"
ratatui = "0.29"
serde = { version = "1", features = ["derive"] }
serde_json = "1"
toml = "0.8"

[target.'cfg(unix)'.dependencies]
libc = "0.2"

[target.'cfg(windows)'.build-dependencies]
winres = "0.1"
```

**Step 4: Create a minimal ICO file**

For now, we'll create a placeholder icon. The actual icon (terminal `>_` symbol) can be designed properly later. Create a minimal valid 32x32 ICO file.

A simple approach: use ImageMagick or Python Pillow in CI, or commit a pre-built `.ico`.

For the implementation, we'll commit a script to generate icons and the resulting files.

Create `scripts/generate_icon.py`:
```python
"""Generate application icons for claude-manager.
Requires: pip install Pillow
"""
from PIL import Image, ImageDraw, ImageFont
import struct
import io

def create_icon_image(size):
    """Create a terminal-style icon at the given size."""
    img = Image.new('RGBA', (size, size), (30, 33, 40, 255))  # dark bg
    draw = ImageDraw.Draw(img)

    # Draw rounded rectangle border
    margin = size // 8
    draw.rounded_rectangle(
        [margin, margin, size - margin, size - margin],
        radius=size // 6,
        outline=(0, 200, 200, 255),  # cyan
        width=max(1, size // 16)
    )

    # Draw ">_" text
    font_size = size // 3
    try:
        font = ImageFont.truetype("arial.ttf", font_size)
    except:
        font = ImageFont.load_default()

    text = ">_"
    bbox = draw.textbbox((0, 0), text, font=font)
    tw, th = bbox[2] - bbox[0], bbox[3] - bbox[1]
    x = (size - tw) // 2
    y = (size - th) // 2
    draw.text((x, y), text, fill=(0, 220, 220, 255), font=font)

    return img

def save_ico(images, path):
    """Save multiple PIL images as a single ICO file."""
    images[0].save(path, format='ICO', sizes=[(img.width, img.height) for img in images])

if __name__ == '__main__':
    sizes = [16, 32, 48, 256]
    images = [create_icon_image(s) for s in sizes]

    # Save ICO (Windows)
    save_ico(images, 'assets/icon.ico')

    # Save PNG (Linux)
    images[-1].save('assets/icon.png')

    print(f"Generated icon files in assets/")
```

**Step 5: Generate and commit icon files**

Run: `pip install Pillow && python scripts/generate_icon.py`

If Pillow is not available, create a minimal placeholder ICO file manually or use an online tool. The key is that `assets/icon.ico` exists for the build.

**Step 6: Build and verify on Windows**

Run: `cargo build 2>&1`
Expected: Compiles successfully, the `.exe` should have the icon embedded

**Step 7: Update release workflow for Linux .desktop file**

In `.github/workflows/release.yml`, update the Linux packaging step to include the icon and a `.desktop` file:

After the Unix tar step, add:
```yaml
      - name: Package (Unix)
        if: matrix.archive == 'tar.gz'
        run: |
          cd target/${{ matrix.target }}/release
          if [ "${{ matrix.target }}" = "x86_64-unknown-linux-gnu" ]; then
            cp ../../../assets/icon.png claude-manager.png
            cat > claude-manager.desktop << 'DESKTOP'
          [Desktop Entry]
          Type=Application
          Name=Claude Manager
          Comment=Manage Claude instances and dev projects
          Exec=claude-manager
          Icon=claude-manager
          Terminal=true
          Categories=Development;
          DESKTOP
            tar czf ../../../claude-manager-${{ matrix.target }}.tar.gz claude-manager claude-manager.png claude-manager.desktop
          else
            tar czf ../../../claude-manager-${{ matrix.target }}.tar.gz claude-manager
          fi
          cd ../../..
```

**Step 8: Commit**

```bash
git add assets/ build.rs scripts/ Cargo.toml .github/workflows/release.yml
git commit -m "feat: add application icon for Windows, macOS, and Linux"
```

---

### Task 7: Theme the selector and input dialogs

**Files:**
- Modify: `src/ui/selector.rs` (apply theme colors)
- Modify: `src/ui/input.rs` (apply theme colors)

**Step 1: Read and update `src/ui/selector.rs`**

Update the `render` method to use theme colors:

Change import:
```rust
use crate::theme;
```

Update block style:
```rust
let list = List::new(items)
    .block(
        Block::default()
            .borders(Borders::ALL)
            .title(title)
            .title_style(theme::accent_title())
            .border_style(theme::active_border()),
    )
    .highlight_style(theme::highlight())
    .highlight_symbol("\u{25B6} ");
```

**Step 2: Read and update `src/ui/input.rs`**

Apply theme to the input dialog border and title:

Add import:
```rust
use crate::theme;
```

Update the block styling to use `theme::active_border()` and `theme::accent_title()`.

**Step 3: Build and verify**

Run: `cargo build 2>&1`
Expected: Compiles successfully

**Step 4: Commit**

```bash
git add src/ui/selector.rs src/ui/input.rs
git commit -m "feat: apply theme to selector and input dialog components"
```

---

### Task 8: Final integration testing and version bump

**Files:**
- Modify: `Cargo.toml` (ensure version is 0.2.0)

**Step 1: Run all tests**

Run: `cargo test 2>&1`
Expected: All existing tests pass

**Step 2: Build release binary**

Run: `cargo build --release 2>&1`
Expected: Builds successfully

**Step 3: Run the app manually and verify**

Run: `cargo run 2>&1` (or launch the release binary)
Verify:
- Navigation between projects is instant (no lag)
- Project list shows colored status indicators
- Details panel has themed Git and Runtime sections
- Port bar shows running count and version
- Help bar has colored run/stop keys
- Update check runs silently in background

**Step 4: Final commit**

```bash
git add -A
git commit -m "chore: v0.2.0 final integration"
```
